# Simulinkモデルの配線最適化

## 1. 概要

`optimizeSimulinkWiring.m` スクリプトの主な目的は、Simulinkモデルの配線を自動的に最適化することです。Simulinkの標準ツールだけでは達成が難しい、人間が行うような整理整頓された配線を目指し、図の可読性と保守性を向上させることを意図しています。具体的には、可能な限り直線を維持し、配線の交差を最小限に抑え、近接する配線を適切に分散させることで、全体として美しく、理解しやすいレイアウトを実現しようとします。このスクリプトは、モデル全体または特定のサブシステムに対して動作し、配線最適化の原則に基づいたルールベースのアプローチを採用しています。

## 2. 入力パラメータ

このスクリプトは、以下の入力パラメータを受け付けます。

*   **`modelName`**: (文字列) 最適化対象のSimulinkモデルファイルへのパス（例: 'myModel.slx'）。これは必須パラメータです。
*   **`preserveLines`**: (ブール値, オプション) 既存の信号線を保持するか、スクリプトによる削除と再描画を許可するかを決定します。
    *   `true`: 既存の線は保持され、スクリプトはそれらを削除せずに整理しようとします。
    *   `false` (デフォルト): 最適化プロセスの一環として、既存の線が削除される可能性があります。
*   **`targetSubsystem`**: (文字列, オプション) 最適化するモデル内の特定のサブシステムへのパス（例: 'myModel/subsystem1'）。
    *   指定された場合、このサブシステムのみが最適化されます。**このパスで指定されたシステムのみを対象とし、その内部のサブシステムを再帰的に処理することはありません。**
    *   指定されない場合、または指定されたサブシステムが見つからない場合、スクリプトはモデル全体の最適化を試みます。

## 3. メイン関数 (`optimizeSimulinkWiring`)

`optimizeSimulinkWiring` 関数はエントリポイントであり、最適化プロセス全体を統括します。

*   **初期化:**
    *   `preserveLines` (デフォルトfalse) が指定されていない場合にデフォルト値を設定します。
    *   グローバル変数 `PRESERVE_EXISTING_LINES` および `WIRING_PARAMS`（デフォルトは `baseOffset: 10, maxOffset: 50, commonXOffset: 50, scaleFactor: 0.5`）を初期化します。

*   **モデルの読み込み:**
    *   指定された `modelName` ファイルが存在するかどうかを確認します。
    *   `load_system` を使用してSimulinkモデルを読み込みます。モデルが既に読み込まれている場合のケースも処理します。

*   **パラメータ設定と最適化対象の決定:**
    *   `targetSubsystem` が指定され、有効な場合は、それが `optimizationTarget` になります。
    *   `targetSubsystem` が指定されていない場合、モデル全体 (`modelBaseName`) が `optimizationTarget` になります。
    *   `optimizeWiringParameters(modelBaseName, optimizationTarget)` 関数が呼び出され、配線パラメータが設定されます（主にデフォルトパラメータが使用されます）。
    *   グローバルな `WIRING_PARAMS` が更新されます。
    *   `targetSubsystem` が指定されていた場合、変更が適用されたモデルはタイムスタンプ付きで保存され、処理は終了します。ファイル名には `_optimized` のような接尾辞が付く場合があります。

*   **コア最適化ステップ:**
    *   出力ディレクトリ `optimization_images` が存在しない場合は作成されます。
    *   最適化 *前* のモデル/サブシステムの画像が `saveModelImage` を使用して保存されます。
    *   **ステップ1: レイアウト分析:** `analyzeModelLayout(modelBaseName)` を呼び出して、ブロックの配置と信号フローに関する情報を収集します。
    *   **ステップ2: ポート位置調整:** このステップは言及されていますが、現在のスクリプトではスキップされています（「特別なケースの処理は不要」）。
    *   **ステップ3: サブシステムごとの配線整理:**
        *   **リンクされたライブラリの保護:** 任意のシステム/サブシステムを処理する前に、それがリンクされたライブラリブロック (`LinkStatus` が `resolved` または `implicit` の `SubSystem` ブロック) かどうかを確認します。リンクされたライブラリの場合、その内部の最適化はスキップされ、警告メッセージがログに記録されます。
        *   `targetSubsystem` が指定されている場合: `optimizeSubsystemWiring(targetSubsystem, preserveLines)` を直接呼び出し、指定されたサブシステムのみを処理します。
        *   `targetSubsystem` が指定されていない場合: `find_system` を使用してモデル内のすべての `SubSystem` タイプのブロックを検索し (`allSystems`)、各サブシステム (`currentSystem`) およびトップレベルモデル (`modelBaseName`) に対して `optimizeSubsystemWiring` を呼び出して処理します。
    *   **ステップ4: 検証と再調整:** `verifyAndReadjust(modelBaseName)` を呼び出して、過度の線交差などの問題がないか確認し、さらに調整を加えます。

*   **結果の保存:**
    *   最適化 *後* のモデル/サブシステムの画像が保存されます。
    *   最適化されたモデルは、ファイル名にタイムスタンプが付加されて保存されます（例: `modelName_YYYYMMDD_HHMMSS.slx`）。
    *   `displayOptimizationMetrics` を使用して最適化品質メトリクスが表示されます。

## 4. 主要なヘルパー関数

*   **`analyzeModelLayout(modelName)`**:
    *   モデルの全体的なレイアウトを分析し、すべてのブロックと信号線に関する情報を収集します。また、事前定義された特定の「特殊ブロック」の位置を特定し、主要な信号フローの方向（例: 左から右）を推定します。
*   **`optimizeSubsystemWiring(subsystemName, preserveLines)`**:
    *   指定された `subsystemName` 内の配線を最適化します。**この関数を呼び出す前に、`subsystemName` がリンクされたライブラリ (`LinkStatus`が `resolved` または `implicit`) でないことを確認する必要があります。もしリンクされたライブラリであれば、この関数の処理をスキップすべきです。**
    *   特別な処理のために `identifySubsystemInputLines` を使用してサブシステム入力線を特定します。
    *   `preserveLines` がtrueの場合、`adjustLinePoints` や `straightenLine` を使用して既存の線を調整します。ポート番号が大きい、または複雑な線は、より大幅な調整を受けます。
    *   `preserveLines` がfalseの場合、入力線と分岐点 (`optimizeBranchPoints`) の処理後、一般的なルーティングに `Simulink.BlockDiagram.routeLine` を使用することがあります。
    *   サブシステム入力に接続する線の専用最適化のために `optimizeSubsystemInputLines` を呼び出します。
    *   線の交差を検出して調整するために `optimizeCrossings` を呼び出します。
*   **`verifyAndReadjust(modelName)`**:
    *   最適化されたモデルの最終チェックを実行します。
    *   潜在的な線交差の数を推定します。多い場合は再調整を試みます。
    *   `preserveLines` がtrueの場合、問題のあるペアに対して `adjustCrossingLines` を呼び出し、複雑な線に対して `simplifyLinePoints` を呼び出します。
    *   `preserveLines` がfalseの場合、線に `autorouting` を再適用することがあります。
    *   直線セグメントの割合などの最終的な品質メトリクスを計算して表示します。
*   **`adjustCrossingLines(line1Handle, line2Handle, points1, points2)`**:
    *   交差する可能性のある2つの線 (`line1Handle`, `line2Handle`) のポイントをシフトすることにより、交差を最小化または排除するように調整します。シフトの方向と大きさは、線の主要な向き（水平/垂直）とポート番号によって異なります。
*   **`straightenLine(points)`**:
    *   線のポイントを変更して、できるだけ直線的にし、水平および垂直セグメントを優先します。接続性を維持しながらポイント数を減らすことを目指します。
*   **`removeRedundantPoints(points)`**:
    *   不要な中間ポイントを削除することにより、線のパスを単純化します。たとえば、3つの連続するポイントが同一直線上にある場合、中間ポイントが削除されます。また、斜めのセグメントを水平と垂直のセグメントの組み合わせに変換します。
*   **`optimizeSubsystemInputLines(lineHandles)`**:
    *   サブシステムの入力ポートに接続する線のレイアウトを特に最適化します。
    *   宛先ブロックごとに線をグループ化し、各グループに対して `optimizeBlockInputLines` を呼び出します。
*   **`optimizeWiringParameters(modelName, subsystemName)`**:
    *   配線パラメータ (`WIRING_PARAMS`) を設定します。主にデフォルトのパラメータセットが使用されます。
*   **`saveModelImage(systemName, outputPath)`**:
    *   指定された `systemName`（モデルまたはサブシステム）のスクリーンショット（PNG画像）を指定された `outputPath` に保存します。最初に `saveas` を試し、失敗した場合は `print` を試みます。
*   **`applyWiringParameters(~, params)`**:
    *   提供された `params` 構造体をグローバル変数 `WIRING_PARAMS` に割り当てる単純なユーティリティ関数。これにより、これらのパラメータが配線プロセスに関与する他の関数からアクセス可能になります。最初の引数（モデル名）は使用されません。
*   **`findAllSubsystems(modelName)`**:
    *   指定された `modelName` 内のすべての 'SubSystem' および 'ModelReference' ブロックへのフルパスのセル配列を検索して返します。

## 5. 特定された弱点

スクリプトのロジックと、潜在的に複雑なモデルに対する人間のような最適化をエミュレートするという目標（`人間の配線最適化プロセス.txt`で示唆されている）に基づくと、いくつかの潜在的な弱点が特定できます。

1.  **ヒューリスティックの限界:**
    *   **ルールの単純さ:** 線の直線化 (`straightenLine`, `removeRedundantPoints`)、交差調整 (`adjustCrossingLines`, `optimizeCrossings`)、オフセット適用 (`adjustLinePoints`, `optimizeBlockInputLines`) のアルゴリズムは、比較的単純な幾何学的ヒューリスティックに依存しています。これらは、複雑、高密度、または型破りなモデルレイアウトには十分に高度ではない可能性があります。
    *   **ヒューリスティックの競合:** 異なる最適化ルールが競合する可能性があります。たとえば、`removeRedundantPoints` を介して線を厳密に水平/垂直に強制すると、意図せずに新しい線の交差が発生したり、斜めのパスが回避に最適であった場合に `adjustCrossingLines` が既存の交差を解決するのが難しくなったりする可能性があります。
    *   **高度なパス検索の欠如:** スクリプトは高度なパス検索アルゴリズム（A*など）を実装していません。主に既存の線ポイントを調整するか、Simulinkの組み込み `autorouting`（`preserveLines` が `false` の場合）を使用しますが、これには独自の制限があり、常に人間のような結果が得られるとは限りません。

2.  **密度と重複の管理:**
    *   **ブロック線/線間の重複:** 基本的な線の交差調整以外に、線がブロック境界や他の線と近接して平行に走ることによる重複を防ぐための明示的で堅牢なメカニズムはありません。`optimizeSubsystemInputLines` や `adjustLinePoints` などの関数におけるルールベースのオフセットは、非常に高密度の図では不十分であり、線を他の要素に押し込む可能性があります。
    *   **高密度図での動作:** 限られたスペースに多くのブロックと信号がある図では、固定オフセット値と単純な調整により、配線が悪くルーティングされたり、新たな重複や非常に近接した平行線が生じたりして、明瞭さが低下する可能性があります。線交差のバウンディングボックスチェックは概算であり、すべてのシナリオで正確なセグメント交差テストではありません。

3.  **最適化範囲（ローカル対グローバル）:**
    *   **サブシステムごとの問題:** サブシステムごとに最適化 (`optimizeSubsystemWiring`) し、次にトップレベルを最適化するアプローチは実用的ですが、準最適なグローバルレイアウトにつながる可能性があります。1つのサブシステムを分離して最適化すると、その境界で配線上の問題が発生し、親システムや隣接/接続されたサブシステムの配線に悪影響を与える可能性があります。
    *   **グローバルな調整の欠如:** 1つのサブシステム内の変更は、最終的なトップレベルの最適化パス以外では、モデル全体のコヒーレンスを保証する方法で他のサブシステムと明示的に調整されていないようです。これにより、インターフェース配線がローカルでは最適でもグローバルでは乱雑になる可能性があります。

4.  **`preserveLines = true` の課題:**
    *   **改善範囲の制限:** `preserveLines` が `true` の場合、スクリプトは既存の線ポイントのみを調整します。これは、特に非常に整理されていないモデルの場合、大幅なレイアウト改善の可能性を著しく制限します。再ルーティング（線の削除と追加/再セグメント化）の機能がないと、多くの問題を修正できません。
    *   **複雑なパスのリスク:** 既存の線を単に「微調整」するだけでは、特に初期配線が既に絡まっている場合に、小さなジグザグや曲がりが蓄積し、線がかえって複雑に見える可能性があります。

5.  **ポート位置決めの省略:**
    *   スクリプトは明示的に `fprintf('Step 2: Port position adjustment skipped (special case processing not needed)...');` と述べています。これは注目すべき省略点です。なぜなら、`人間の配線最適化プロセス.txt` は手動最適化の重要なステップとして「ポート位置の微調整」を強調しているからです。最適な線ルーティングは、多くの場合、良好なポート配置に大きく依存します。これをスキップすることにより、スクリプトはその後の線ルーティングでは完全には克服できない根本的なハンディキャップを抱えて作業している可能性があります。

6.  **決定論と安定性:**
    *   処理要素の順序（例: `optimizeSubsystemWiring` 内の線、メインループ内のサブシステム、または `optimizeCrossings` 内の線ペア）が厳密かつ一貫して制御されていない場合（例: 要素をハンドルや名前でソートするなど）、同じ入力モデルとパラメータに対して出力にわずかなばらつきが生じる可能性があります。これは、1つのヒューリスティックの結果が次のヒューリスティックの入力に影響を与える可能性があるためです。幾何学的計算における浮動小数点精度も、複雑なシナリオでは微細な違いに寄与する可能性があります。完全な決定論の欠如は、デバッグを困難にする可能性があります。

7.  **スケーラビリティとパフォーマンス:**
    *   **繰り返されるクエリ:** スクリプトは `find_system` を複数回、時にはループ内で使用します。線ポイントに対する `get_param` や `set_param` などの関数もループ内で繰り返し呼び出されます。
    *   **計算の複雑さ:** 何千ものブロックと線を持つ非常に大きなモデルの場合、これらの繰り返されるクエリと変更は計算コストが高くなる可能性があります。`verifyAndReadjust` および `optimizeCrossings` での線交差検出には、線ペアに対するネストされたループ（高密度チェックの場合、最悪ケースでN線に対してO(N^2)の可能性あり）が含まれており、非常に遅くなる可能性があります。これは、大規模な産業モデルでは非実用的なほど長い実行時間につながる可能性があります。

## 6. 提案される解決策と改善策

特定された弱点に対処し、`人間の配線最適化プロセス.txt` から着想を得て、`optimizeSimulinkWiring.m` スクリプトに対して以下の解決策と改善策を提案します。

### 1. コアアルゴリズムの強化

*   **配線ルーティングの改善:**
    *   **高度なパス検索の導入の検討:** 大幅な再ルーティングが必要な線については、より高度なパス検索アルゴリズム（A*など）の導入を検討します。これにより、障害物を考慮した最適な経路を見つける能力の向上が期待できます。
    *   **包括的なコスト関数の設計思想:** 配線経路を評価するためのコスト関数を導入する際は、線長、曲がり数、角度、他要素との近接性、交差ペナルティなどを総合的に考慮する設計が望ましいです。
    *   **セグメント単位での再ルーティング戦略:** `preserveLines = false` の場合、問題のある線を削除し、現在のレイアウトを考慮したパス検索アルゴリズムを用いて再描画するアプローチを検討します。

*   **ポート位置の最適化戦略:**
    *   **「ポート位置調整」ステップの具体化:** スキップされている「ポート位置調整」ステップを具体化し、ポートの整列、均等配置、ブロックの微調整、ポートグループに対する一括ルーティングなどの機能の実装を検討します。これらは人間の作業プロセスにおける配慮点と一致します。

*   **ブロック間隔・レイアウト調整（前処理）のアイデア:**
    *   **自動間隔調整の導入:** ブロックレイアウトを分析し、ブロック間の距離が近すぎる場合に自動で調整する前処理ステップの導入を検討します。
    *   **フローに合わせた整列の試み:** 信号フローが直接的なブロック同士を整列させ、より直線的な配線を促進するロジックを検討します。

*   **交差最小化戦略:**
    *   **グラフベースアプローチの可能性:** 複雑な状況に対応するため、グラフ理論に基づいた交差最小化技術の適用可能性を調査します。
    *   **ルーティングコストへの交差ペナルティ組込み:** パス検索のコスト関数に交差ペナルティを直接組み込むことで、交差を回避する経路選択を促進します。

*   **直交ルーティングの改良方針:**
    *   **より厳密な直交性の確保:** 水平・垂直セグメントの厳密な適用を目指します。
    *   **角のスタイル制御の検討:** （Simulinkの機能範囲内で）角のスタイルを制御するオプションを検討し、クリーンな90度曲げを優先します。
    *   **冗長セグメント除去の強化:** `removeRedundantPoints` を強化し、線を標準的な直交形式に積極的に単純化する方向で改良します。

### 2. ユーザーインタラクションと制御（`人間の配線最適化プロセス.txt` から着想）

*   **インタラクティブモードの導入:**
    *   **選択的最適化の実現:** ユーザーが特定の範囲（サブシステム、ブロック群、個々の線やポート）を選択し、その部分にのみ最適化を適用できる機能を実装します。
    *   **変更プレビュー機能:** 変更を適用する前に、提案される変更点を視覚的にプレビューできる機能（一時的なグラフィカル注釈など）を検討します。

*   **ユーザー確認を伴う段階的最適化プロセスの導入:**
    *   最適化プロセスを複数の明確なフェーズに分割し、各フェーズの実行、結果確認、パラメータ調整、そして次のステップへ進むという、ユーザーが制御可能な段階的実行を可能にすることを検討します。これは人間の作業プロセスにおける「段階的な最適化」や「結果の確認と再調整」の考え方と一致します。

*   **強化された視覚的フィードバックの提供:**
    *   **変更点のハイライト:** 最適化前後の画像比較において、大幅に変更された線や問題領域（検出された交差、長すぎる線など）を強調表示する機能を検討します。
    *   **画像へのメトリクス表示:** オプションとして、主要な品質メトリクスを最適化後の画像に注釈表示することを検討します。

*   **カスタマイズ可能なルールと優先順位の設定:**
    *   ユーザーが異なる最適化目標の相対的な重要性（例：「交差最小化」>「線長最小化」>「曲がり最小化」）を設定ファイルやUIを通じて定義できるメカニズムの導入を検討します。これにより、コスト関数や最適化ステップの順序・積極性が変化します。

### 3. `preserveLines` モードの強化

*   **「スマート保存」再ルーティングの導入:**
    *   単にポイントを調整するだけでなく、局所的な小規模な再ルーティングを許可することを検討します。例えば、不自然な迂回を持つ線に対し、始点と終点を維持したまま、少数のセグメントの追加・削除によって経路を単純化することを目指します。
    *   目標は、元の経路から大きく逸脱することなく、明瞭さを大幅に改善し、曲がりを減らすことです。
*   **対象を絞ったローカルクリーンアップの強化:**
    *   `preserveLines` モードにおいて、不要な曲がりの削減、既存固定点間のセグメント直線化、および局所的な混雑緩和に、より焦点を当てた調整を行います。

### 4. パフォーマンスと決定論

*   **パフォーマンス最適化戦略:**
    *   **プロファイリングの実施:** 大規模モデルでスクリプトをプロファイリングし、ボトルネックを特定します。
    *   **`get/set_param` 呼び出しの削減:** ループ内でのこれらの関数の呼び出しを最小限に抑えるため、データの一括取得・適用を検討します。
    *   **効率的なクエリの実現:** `find_system` の使用を最適化し、結果のキャッシュやより具体的なパラメータ指定を行います。
    *   **アルゴリズム効率の向上:** 交差検出などの計算量が多い処理について、空間インデックスのような技術を用いて効率化を検討します。

*   **決定論の確保への取り組み:**
    *   **一貫したオブジェクト順序付けの徹底:** オブジェクトのリストを取得する際は常に一貫した基準でソートし、操作の順序が毎回同じになるようにします。
    *   **慎重な浮動小数点比較の実施:** 幾何学的計算における浮動小数点誤差の影響を考慮し、比較には適切な許容誤差（イプシロン値）を使用します。

これらの提案は、より堅牢で柔軟、かつ効果的な配線最適化ツールを構築し、現実のSimulinkモデルの複雑性に対応し、人間の専門家による最適化手法により近い結果を目指すものです。

## 7. 今後の展望

将来的には、AI技術を活用して配線の品質評価や最適化パラメータの自動調整を行うといった拡張も考えられます。これには、機械学習モデルを用いた画像解析や、より高度な探索アルゴリズムとの連携などが含まれる可能性があります。
